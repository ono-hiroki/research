\expandafter\ifx\csname ifdraft\endcsname\relax
\documentclass{jsarticle}
\begin{document}
    \fi
    \section{提案手法}
    本研究では、関連研究にある複合層、多層の機能追加
    react copの改善点を洗い出し、それを解決するための機能を追加した。
    本章では、本研究で提案する手法について述べる。

    react copでは、レイヤーの活性化情報をuseStateを用いて管理している。state変数はクラスのインスタンスを用いている。
    しかし、state変数は参照型のため、state変数の値を変更しても再レンダリングが行われない。
    そのため、レイヤーの活性化情報を更新しても、再レンダリングが行われない。
    これを解決するために、state変数を参照型のクラスのインスタンスから、イミュータブルなデータに変更する必要がある。
    この変更はreact copを大きく刷新することと同等であるため、react cop2として新しく実装することとした。

    react copでは、レイヤーのパラメーターとlayerの活性化情報を別で管理している。
    そのため、レイヤーの活性化とレイヤーのパラメーターで2度レイヤー名を指定する必要がある。
    これは、レイヤーの管理が煩雑になる原因となっている。
    この問題を解決するために、レイヤーを一つのオブジェクトとして管理することとした。

    以降では、react cop2の実装について述べる。
    react copで代替となる機能を提供するために、react cop2では、以下の機能を提供する。
    react copから改善された機能を以下に示す。


%     layerの管理の方法を大きく変更した。
%     同じくuseStateを用いてlayerの管理を行うが、state変数を参照型のクラスのインスタンスから、イミュータブルなデータ構造である配列に変更した。
%     state変数を参照型にしてしまうと、state変数の値を変更が検知できないため、再レンダリングが行われない。
%     しかし、イミュータブルなデータ構造である配列に変更することで、state変数の値の変更を検知できるようになった。




    \subsection{代替する機能}
    \subsubsection{アクティブなレイヤーの一つを取得できる}
    \subsubsection{レイヤー名を指定してレイヤーを取得できる}
    \subsubsection{レイヤー名を指定してレイヤーをアクティブにできる}
    \subsubsection{レイヤー名を指定してレイヤーを非アクティブにできる}



    \subsection{改善点}

    \subsubsection{改善点一覧}
    \begin{itemize}
    \item layerのde/active時に新しいレイヤーを定義できないようにする
    \item layer paramsはin/activeの両方の状態を持つ
    \item layer paramsはlayerのin/active状態に依存をするようにしたい
    \item layer paramsの値を入れるときに新しいlayerを定義できないようにする
    \item layer grop的なのをついか
    \item layerの活性化条件を定義できる
    \begin{itemize}
    \item 複合層
    \item 多層
    \end{itemize}
    \item layerの活性化は排反
    \item typescriptでの実装
    \item テストの追加
    \end{itemize}

    \subsubsection{layerのde/active時に新しいレイヤーを定義できないようにする}
    react copでは、layerのde/active時に新しいレイヤーを定義できてしまう。
    layerのde/active時に新しいレイヤーを定義できると意図しないレイヤーが簡単に定義できてしまう。
    またレイヤーの管理が煩雑になる。

    react cop2では、layerのde/active時に新しいレイヤーを定義できないようにする。
    これによって、意図しないレイヤーが簡単に定義できなくなり、レイヤーの管理が煩雑にならない。


    \subsubsection{layer paramsはin/activeの両方の状態を持つ}

    \subsubsection{layer paramsはlayerのin/active状態に依存をするようにしたい}

    \subsubsection{layer paramsの値を入れるときに新しいlayerを定義できないようにする}

    \subsubsection{layer grop的なのをついか}

    \subsubsection{layerの活性化条件を定義できる}

    \subsubsection{layerの活性化は排反}
        \begin{lstlisting}[caption=hoge,label=fuga]
        // このとき、FloatとIntegerのレイヤの活性化は排反でよい気がする
        const [getHoge, setHoge] = useLayerParams('', ["Float", "Integer"]);

        // いちいち切り替えがめんどう
        layerManager.deactivateLayer("Integer");
        layerManager.activateLayer("Float");


        // 排反ではないから２つ条件含むのどうなん？
        <Layer condition={layerState.Float && !layerState.Integer}>
        \end{lstlisting}

    \subsection{実装する内容}

    \subsubsection{typescriptでの実装}

    \subsubsection{テストの追加}


    \subsection{評価方法}
    - 実装前と後で、できることの違いを比較する。
















    \expandafter\ifx\csname ifdraft\endcsname\relax
\end{document}
\fi
